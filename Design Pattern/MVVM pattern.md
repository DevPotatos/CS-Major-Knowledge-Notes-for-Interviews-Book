# MVVM 패턴

> MVVM 패턴은 MVC의 컨트롤러가 뷰모델(View Model)로 바뀐 패턴이다.
>
> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5ZE36%2Fbtq2lqcQohU%2FekNc9XgOcJcyqfEtMbltTk%2Fimg.png" style="zoom:50%;" />



## 뷰모델(View Model)

> 뷰모델은 뷰를 더 추상화한 계층

### 역할

- 뷰를 나타내기 위한 데이터 처리

### 동작 과정

1. 뷰를 통해 사용자의 입력이 들어옴
2. 뷰에서 입력이 들어오면 command 패턴으로 뷰모델이 입력 전달
3. 뷰모델은 필요한 데이터를 모델에게 요청
4. 모델은 뷰모델에게 요청된 데이터 응답
5. 뷰모델은 응답 받은 데이터를 가공해서 저장
6. 뷰는 뷰모델과의 데이터 바인딩으로 자동 갱신됨



## MVVM 패턴의 예

### 뷰(Vue.js)

> 뷰는 반응형(reactivity)이 특징인 프론트엔드 프레임워크

- 함수를 사용하지 않고 값 대입만으로도 변수 변경 가능

- 양방향 바인딩, html을 토대로 컴포넌트 구축 가능

- 재사용 가능한 컴포넌트 기반으로 UI 구축 가능




## 특징

### MVC와의 차이

- MVVM 패턴은 `커맨드(command)`와 `데이터 바인딩(data binding)`을 가짐

  - **커맨드**
    - 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
    - 뷰에 입력이 들어오면 커맨드를 통해 뷰모델에 명령

  - **데이터 바인딩**
    - 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법
    - 뷰모델의 값이 변하면 자동으로 UI 업데이트
    - **뷰와 뷰모델 사이 의존성 없음**
  
  
  => **뷰와 뷰모델 사이의 양방향 데이터 바인딩 지원**

### 장점

- UI를 별도의 코드 수정 없이 재사용 가능
- 뷰와 뷰모델 사이 의존성 없음
- 뷰와 모델 사이 의존성이 없음 
- 독립성 유지
  - 효율적인 유닛테스트 가능
  - 모듈화 가능

### 단점

- 단순한 UI에서는 뷰모델 설계하는 것이 과한 것일 수 있음
- 뷰에 대한 처리가 복잡해질수록 뷰모델이 거대해져 오버스펙이 될 수 있음
-  애플리케이션이 복잡해질수록 애플리케이션의 메모리 소모가 데이터 바인딩 때문에 커짐
- 표준화된 틀이 존재하지 않음
  - 뷰모델의 설계가 쉽지 않음




---

### References

https://jhtop0419.tistory.com/21

https://zerocodings.com/11

https://velog.io/@dev_space/MVVM-%ED%8C%A8%ED%84%B4
